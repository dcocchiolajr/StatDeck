/**
 * Main Application Controller - StatDeck Display
 * VERSION: Unified Theme System v3.1
 * 
 * ALL themes flow through Config App → dynamic CSS injection.
 * Enhanced CSS generation for rich visual effects matching
 * the quality of the old per-theme hardcoded rules.
 */

class StatDeckApp {
    constructor() {
        this.config = null;
        this.usbClient = new USBClient();
        this.tileManager = null;
        this.layoutEngine = null;
        this.touchHandler = new TouchHandler();
        this.init();
    }
    
    init() {
        console.log('StatDeck initializing...');
        
        this.usbClient.on('connected', () => {
            console.log('Connected to backend');
            this.hideDisconnectedOverlay();
        });
        
        this.usbClient.on('disconnected', () => {
            console.log('Disconnected from backend');
            this.showDisconnectedOverlay();
        });
        
        this.usbClient.on('config', (layout) => {
            console.log('Received configuration');
            this.loadConfig(layout);
        });
        
        this.usbClient.on('stats', (data) => {
            this.updateStats(data);
        });
        
        this.touchHandler.on('tap', (tileId) => {
            this.handleTileAction(tileId, 'tap');
        });
        
        this.touchHandler.on('long_press', (tileId) => {
            this.handleTileAction(tileId, 'long_press');
        });
        
        this.usbClient.connect();
    }
    
    loadConfig(layout) {
        this.config = layout;
        
        if (layout.themeData && layout.themeData.colors) {
            const themeId = layout.theme || layout.themeData.id || 'custom';
            
            document.body.setAttribute('data-theme', themeId);
            this.applyThemeData(layout.themeData);
            this.injectThemeColorsIntoTiles(layout.tiles, layout.themeData);
            this.injectThemeCSS(layout.themeData, themeId);
            
            console.log(`Theme applied: ${themeId} (${layout.themeData.name || 'unnamed'})`);
        } else if (layout.theme) {
            document.body.setAttribute('data-theme', layout.theme);
            console.log(`Legacy theme: ${layout.theme}`);
        }
        
        this.layoutEngine = new LayoutEngine(layout.grid);
        this.layoutEngine.apply();
        
        this.tileManager = new TileManager(layout.tiles);
        this.tileManager.createTiles();
        
        this.touchHandler.registerTiles(this.tileManager.tiles);
        
        console.log('Configuration loaded');
    }
    
    applyThemeData(themeData) {
        const root = document.documentElement;
        const c = themeData.colors;
        
        root.style.setProperty('--theme-primary', c.primary);
        root.style.setProperty('--theme-secondary', c.secondary);
        root.style.setProperty('--theme-accent', c.accent);
        root.style.setProperty('--theme-background', c.background);
        root.style.setProperty('--theme-surface', c.surface);
        root.style.setProperty('--theme-text', c.text);
        root.style.setProperty('--theme-text-secondary', c.textSecondary);
        root.style.setProperty('--theme-border', c.border);
        
        if (themeData.fonts) {
            root.style.setProperty('--theme-font-main', themeData.fonts.main);
            root.style.setProperty('--font-main', themeData.fonts.main);
            root.style.setProperty('--font-mono', themeData.fonts.mono);
            document.body.style.fontFamily = themeData.fonts.main;
        }
        
        document.body.style.setProperty('background', c.background, 'important');
        document.getElementById('app').style.setProperty('background', c.background, 'important');
    }
    
    injectThemeColorsIntoTiles(tiles, themeData) {
        const c = themeData.colors;
        const valueColor = c.valueColor || c.primary;
        
        tiles.forEach(tile => {
            if (!tile.style) tile.style = {};
            if (!tile.style.color || tile.style.color === '') {
                tile.style.color = valueColor;
            }
            if (!tile.style.background || tile.style.background === '') {
                tile.style.background = c.surface;
            }
            // Support per-tile label color override
            if (!tile.style.labelColor || tile.style.labelColor === '') {
                tile.style.labelColor = c.textSecondary;
            }
        });
    }
    
    /**
     * Generate rich, theme-quality CSS dynamically.
     * This replaces the old hardcoded per-theme rules in themes.css.
     */
    injectThemeCSS(themeData, themeId) {
        const c = themeData.colors;
        const eff = themeData.effects || {};
        const valueColor = c.valueColor || c.primary;
        const surfaceDark = this.darkenColor(c.surface, 15);
        const surfaceLight = this.lightenColor(c.surface, 10);
        
        let styleTag = document.getElementById('dynamic-theme-style');
        if (!styleTag) {
            styleTag = document.createElement('style');
            styleTag.id = 'dynamic-theme-style';
            document.head.appendChild(styleTag);
        }
        
        const sel = `body[data-theme="${themeId}"]`;
        const allTiles = `${sel} .tile, ${sel} .cpu-graph-tile, ${sel} .gauge-tile, ${sel} .text-display-tile, ${sel} .button-tile, ${sel} .network-graph-tile`;
        let css = '';
        
        // ── TILE BACKGROUNDS AND BORDERS ──
        if (eff.glow) {
            // Rich glow: gradient bg, colored border, multi-layer shadow
            css += `
                ${allTiles} {
                    background: linear-gradient(135deg, ${c.surface} 0%, ${surfaceDark} 100%) !important;
                    border: 2px solid ${c.primary} !important;
                    box-shadow: 
                        0 0 20px ${c.primary}80,
                        0 0 40px ${c.secondary ? c.secondary + '50' : c.primary + '30'},
                        inset 0 0 30px ${c.primary}15 !important;
                }
            `;
        } else if (eff.bevel) {
            css += `
                ${allTiles} {
                    background: linear-gradient(180deg, ${surfaceLight} 0%, ${c.surface} 50%, ${surfaceDark} 100%) !important;
                    border: none !important;
                    border-radius: 4px !important;
                    box-shadow: 
                        inset 2px 2px 0 rgba(255,255,255,0.3),
                        inset -2px -2px 0 rgba(0,0,0,0.3),
                        inset 3px 3px 0 rgba(255,255,255,0.15),
                        inset -3px -3px 0 rgba(0,0,0,0.15),
                        3px 3px 6px rgba(0,0,0,0.25) !important;
                }
                ${sel} .tile:active, ${sel} .button-tile:active {
                    box-shadow: 
                        inset 2px 2px 0 rgba(0,0,0,0.3),
                        inset -2px -2px 0 rgba(255,255,255,0.3),
                        1px 1px 3px rgba(0,0,0,0.15) !important;
                    transform: translate(1px, 1px);
                }
            `;
        } else {
            // Standard: subtle gradient, clean border
            css += `
                ${allTiles} {
                    background: linear-gradient(135deg, ${surfaceLight} 0%, ${c.surface} 100%) !important;
                    border: 1px solid ${c.border} !important;
                    box-shadow: 
                        0 2px 8px rgba(0,0,0,0.3),
                        inset 0 1px 0 ${surfaceLight}40 !important;
                }
            `;
        }
        
        // ── VALUE TEXT ──
        if (eff.glow) {
            css += `
                ${sel} .tile-value, ${sel} .gauge-value, ${sel} .text-display-value {
                    color: ${valueColor} !important;
                    text-shadow: 
                        0 0 10px ${valueColor},
                        0 0 20px ${valueColor},
                        0 0 30px ${valueColor}80;
                    font-weight: 700;
                }
            `;
        } else if (eff.bevel) {
            css += `
                ${sel} .tile-value, ${sel} .gauge-value, ${sel} .text-display-value {
                    color: ${valueColor} !important;
                    font-weight: 700;
                    text-shadow: 
                        -1px -1px 0 rgba(255,255,255,0.4),
                        1px 1px 0 rgba(0,0,0,0.3);
                }
            `;
        } else {
            css += `
                ${sel} .tile-value, ${sel} .gauge-value, ${sel} .text-display-value {
                    color: ${valueColor} !important;
                }
            `;
        }
        
        // ── LABEL TEXT ──
        if (eff.glow) {
            css += `
                ${sel} .tile-label, ${sel} .gauge-label, ${sel} .text-display-label {
                    color: ${c.textSecondary} !important;
                    text-shadow: 
                        0 0 10px ${c.textSecondary},
                        0 0 20px ${c.textSecondary}80;
                    text-transform: uppercase;
                    letter-spacing: 2px;
                }
            `;
        } else if (eff.bevel) {
            css += `
                ${sel} .tile-label, ${sel} .gauge-label, ${sel} .text-display-label {
                    color: ${c.textSecondary} !important;
                    text-shadow: 
                        1px 1px 0 rgba(255,255,255,0.4),
                        -1px -1px 0 rgba(0,0,0,0.2);
                }
            `;
        } else {
            css += `
                ${sel} .tile-label, ${sel} .gauge-label, ${sel} .text-display-label {
                    color: ${c.textSecondary} !important;
                }
            `;
        }
        
        // ── SVG GAUGE STYLING ──
        // Gauge track (background circle/arc)
        css += `
            ${sel} .gauge-svg circle[stroke="#333"],
            ${sel} .gauge-svg path[stroke="#333"] {
                stroke: ${this.darkenColor(c.surface, 25)} !important;
            }
        `;
        // Gauge fill uses tile's style.color which we injected
        // But add glow filter for glow themes
        if (eff.glow) {
            css += `
                ${sel} .gauge-svg circle:not([stroke="#333"]),
                ${sel} .gauge-svg path:not([stroke="#333"]) {
                    filter: drop-shadow(0 0 6px ${valueColor}) drop-shadow(0 0 12px ${valueColor}80);
                }
            `;
        }
        
        // ── GRAPH LINE STYLING ──
        if (eff.glow) {
            css += `
                ${sel} .cpu-graph path, ${sel} .network-graph path {
                    filter: drop-shadow(0 0 6px ${valueColor});
                }
            `;
        }
        
        // ── SCANLINES EFFECT ──
        if (eff.scanlines) {
            css += `
                ${sel}::after {
                    content: '';
                    position: fixed;
                    top: 0; left: 0;
                    width: 100%; height: 100%;
                    background: repeating-linear-gradient(
                        0deg,
                        rgba(0,0,0,0.15),
                        rgba(0,0,0,0.15) 1px,
                        transparent 1px,
                        transparent 2px
                    );
                    pointer-events: none;
                    z-index: 9999;
                }
            `;
        }
        
        // ── PIXELATED EFFECT ──
        if (eff.pixelated) {
            css += `
                ${sel}, ${sel} .tile {
                    image-rendering: pixelated;
                    image-rendering: -moz-crisp-edges;
                }
                ${sel} * {
                    font-smooth: never;
                    -webkit-font-smoothing: none;
                }
                ${sel} .tile { border-radius: 0 !important; }
            `;
        }
        
        // ── FONT OVERRIDE ──
        if (themeData.fonts && themeData.fonts.main) {
            css += `
                ${sel}, ${sel} .tile, ${sel} .tile-label, ${sel} .tile-value,
                ${sel} .gauge-label, ${sel} .gauge-value,
                ${sel} .text-display-label, ${sel} .text-display-value {
                    font-family: ${themeData.fonts.main} !important;
                }
            `;
        }
        
        // ── LINEAR GAUGE BAR STYLING ──
        // Linear gauge bars use inline styles set by JS, but we can add glow
        if (eff.glow) {
            css += `
                ${sel} .gauge-container div div {
                    box-shadow: 0 0 10px ${valueColor}80;
                }
            `;
        }
        
        styleTag.textContent = css;
    }
    
    lightenColor(hex, percent) {
        try {
            const num = parseInt(hex.replace('#', ''), 16);
            const r = Math.min(255, (num >> 16) + Math.round(2.55 * percent));
            const g = Math.min(255, ((num >> 8) & 0x00FF) + Math.round(2.55 * percent));
            const b = Math.min(255, (num & 0x0000FF) + Math.round(2.55 * percent));
            return '#' + (0x1000000 + (r << 16) + (g << 8) + b).toString(16).slice(1);
        } catch (e) { return hex; }
    }
    
    darkenColor(hex, percent) {
        try {
            const num = parseInt(hex.replace('#', ''), 16);
            const r = Math.max(0, (num >> 16) - Math.round(2.55 * percent));
            const g = Math.max(0, ((num >> 8) & 0x00FF) - Math.round(2.55 * percent));
            const b = Math.max(0, (num & 0x0000FF) - Math.round(2.55 * percent));
            return '#' + (0x1000000 + (r << 16) + (g << 8) + b).toString(16).slice(1);
        } catch (e) { return hex; }
    }
    
    updateStats(data) {
        if (this.tileManager) {
            this.tileManager.updateAllTiles(data);
        }
    }
    
    handleTileAction(tileId, actionType) {
        console.log(`Tile action: ${tileId}.${actionType}`);
        this.usbClient.sendAction(tileId, actionType);
    }
    
    showDisconnectedOverlay() {
        document.getElementById('disconnected-overlay').classList.remove('hidden');
    }
    
    hideDisconnectedOverlay() {
        document.getElementById('disconnected-overlay').classList.add('hidden');
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => { window.app = new StatDeckApp(); });
} else {
    window.app = new StatDeckApp();
}
